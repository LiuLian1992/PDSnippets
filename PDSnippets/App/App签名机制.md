# App签名机制

## 三种安全强度的签名设计

#### 第一种：客户端加密(对称加密，如 AES)，服务端解密，配合 token 和流水号

优点：能够保持用户登录状态、区分用户，相对于不返回任何信息的登录要安全了一些。

缺点：如果通过网络嗅探器（例如：青花瓷）可以获取到http链接，会造成信息泄露，并且还能被伪造请求。

#### 第二种：客户端加密(非对称加密，如 RSA)，服务端解密，配合 token 和流水号

采用 RSA 非对称加密。具体流程如下：

- 客户端向服务器第一次发起登录请求（不传输用户名和密码）。

- 服务器利用RSA算法产生一对公钥和私钥。并保留私钥， 将公钥发送给客户端。

- 客户端收到公钥后， 加密用户密码， 向服务器发起第二次登录请求（传输用户名和加密后的密码）。

- 服务器利用保留的私钥对密文进行解密，得到真正的密码。

#### 第三种：非对称加密 + token + 流水号
前两种方法如果 token 被截获了，那么他人完全就能够模拟出用户的请求，所以在服务器向客户端发送的 token 数据，也需要加密。

具体流程如下：

- 客户端向服务器第一次发起登录请求（不传输用户名和密码），服务器利用RSA算法产生一对公钥和私钥。并保留私钥， 将公钥发送给客户端。

- 客户端收到公钥后， 加密用户密码，向服务器发送用户名和加密后的用户密码； 同时另外产生一对公钥和私钥，自己保留私钥, 向服务器发送公钥； 于是第二次登录请求传输了用户名和加密后的密码以及客户端生成的公钥。

- 服务器利用保留的私钥对密文进行解密，得到真正的密码。 经过判断， 确定用户可以登录后，生成sessionId和token， 同时利用客户端发送的公钥，对token进行加密。最后将sessionId和加密后的token返还给客户端。

- 客户端利用自己生成的私钥对token密文解密， 得到真正的token。


### token
token 是服务端用来识别用户的特定字符串，带有效期。

#### 使用场景

- 服务器接收到app发送的用户名和密码后，需验证用户名和密码是否正确

- 如果验证正确，生成一个随机的不重复的token字符串

- 服务器把token字符串返回给app，app把这个token字符串保存起来，作为登录的验证

- 当需要验证用户身份的操作时，必须要把token字符串传给服务器验证身份

- 当用户退出登录时，服务器会把这个用户对应的 token 删除

以上第二步会在 redis 或 memcache 中维护一个映射表，建立 token 字符串和用户信息的对应关系表。

例如，把token字符串"asd"和用户id"1"对应起来。

### 流水号
流水号 “{seqId}” 为每次请求的唯一标识，会附加在请求 url 后面，如果请求的流水号没有发生变化，则认为是重复请求。

### 加密
常用的有 AES、RSA。
